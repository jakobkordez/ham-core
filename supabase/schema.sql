
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE SCHEMA IF NOT EXISTS "public";

ALTER SCHEMA "public" OWNER TO "pg_database_owner";

COMMENT ON SCHEMA "public" IS 'standard public schema';

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."log" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"(),
    "name" character varying,
    "call" character varying NOT NULL,
    "dxcc" integer NOT NULL,
    "country" character varying NOT NULL,
    "grid" character varying,
    "cqz" smallint,
    "ituz" smallint,
    "title" character varying
);

ALTER TABLE "public"."log" OWNER TO "postgres";

ALTER TABLE "public"."log" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."profile_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."qso" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "call" character varying NOT NULL,
    "datetime" timestamp with time zone NOT NULL,
    "mode" character varying NOT NULL,
    "frequency" bigint NOT NULL,
    "rst_sent" character varying,
    "rst_rcvd" character varying,
    "power" integer,
    "comment" "text",
    "dxcc" integer DEFAULT 0 NOT NULL,
    "country" character varying,
    "other" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "log_id" bigint,
    "band" character varying,
    "gridsquare" character varying
);

ALTER TABLE "public"."qso" OWNER TO "postgres";

ALTER TABLE "public"."qso" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."qso_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."user_info" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "call" character varying,
    "name" character varying,
    "default_log_id" bigint
);

ALTER TABLE "public"."user_info" OWNER TO "postgres";

ALTER TABLE "public"."user_info" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_info_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."log"
    ADD CONSTRAINT "profile_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."qso"
    ADD CONSTRAINT "qso_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_info"
    ADD CONSTRAINT "user_info_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_info"
    ADD CONSTRAINT "user_info_user_id_key" UNIQUE ("user_id");

CREATE INDEX "qso_datetime_idx" ON "public"."qso" USING "brin" ("datetime");

CREATE INDEX "qso_log_id_idx" ON "public"."qso" USING "btree" ("log_id");

ALTER TABLE ONLY "public"."log"
    ADD CONSTRAINT "profile_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."qso"
    ADD CONSTRAINT "qso_profile_id_fkey" FOREIGN KEY ("log_id") REFERENCES "public"."log"("id");

ALTER TABLE ONLY "public"."qso"
    ADD CONSTRAINT "qso_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."user_info"
    ADD CONSTRAINT "user_info_default_log_id_fkey" FOREIGN KEY ("default_log_id") REFERENCES "public"."log"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."user_info"
    ADD CONSTRAINT "user_info_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

CREATE POLICY "Enable insert for users based on user_id" ON "public"."log" FOR INSERT WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable insert for users based on user_id" ON "public"."qso" FOR INSERT WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable insert for users based on user_id" ON "public"."user_info" FOR INSERT WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable read access for all users" ON "public"."qso" FOR SELECT USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."log"
  WHERE ("log"."id" = "qso"."log_id")))));

CREATE POLICY "Enable read access for all users" ON "public"."user_info" FOR SELECT USING (true);

CREATE POLICY "Enable read access for auth users" ON "public"."log" FOR SELECT USING ((("auth"."uid"() = "user_id") OR ("user_id" IS NULL)));

CREATE POLICY "Enable update for users by id" ON "public"."user_info" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

ALTER TABLE "public"."log" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."qso" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_info" ENABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON TABLE "public"."log" TO "anon";
GRANT ALL ON TABLE "public"."log" TO "authenticated";
GRANT ALL ON TABLE "public"."log" TO "service_role";

GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."qso" TO "anon";
GRANT ALL ON TABLE "public"."qso" TO "authenticated";
GRANT ALL ON TABLE "public"."qso" TO "service_role";

GRANT ALL ON SEQUENCE "public"."qso_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."qso_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."qso_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."user_info" TO "anon";
GRANT ALL ON TABLE "public"."user_info" TO "authenticated";
GRANT ALL ON TABLE "public"."user_info" TO "service_role";

GRANT ALL ON SEQUENCE "public"."user_info_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_info_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_info_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
